{"./":{"url":"./","title":"介绍","keywords":"","body":"小浩算法 小浩算法目前共完成 105道 高频面试算法题目，全部采用漫画图解的方式。 面向算法小白和初中阶读者。 采用 Java 和 Go，后期会配更多的语言。 现有代码全部在 leetcode 上测试运行，可供系统刷题使用。 该教程目前共有 11w 人阅读 为了大家更好的交流，我创建了万人刷题群 下方扫码回复【进群】 即可（群里无广告，不套路，不推送） 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-06 09:33:08 "},"c99/hello.html":{"url":"c99/hello.html","title":"阅读指南","keywords":"","body":"阅读指南 为什么要做这样的一个算法图解合集 网上的算法教程杂乱且分散，质量层次不齐，浪费了大家大量宝贵的时间。很多题解，在我掌握题目后去看都费劲，更何况对于一些初学者。 本教程阅读门槛 本教程基本没有学习门槛。因为在每道题目中，我都会尽量去串基础知识，以达到学以致用的效果。 学完本教程期望达到什么样的目的 掌握基本的数据结构与算法 掌握各类型高频面试算法题 本教程有何特色 每一道算法题都配有完整图解！仅此一家！ 题解是围绕什么编写的 掌握！所有的题解都以掌握二字为前提。不会追求过多的奇淫技巧，毕竟我们不是专门研究算法的人。我见过太多算法初学者，一个题解看不懂，转头又去看第二个题解，第二个看不懂，又去看第三个，直到最后放弃掉。浪费了时间，题目还是不会做，这图什么呢？所以本教程所有的题解都是以掌握为目标，尽量把每一道题的思路都讲的明明白白的。 题解是否严谨 绝对严谨，所有的题解都在leetcode上进行过测试运行。 没学过 java、go 是否可以学习 当然可以。我期望大家更多的是去关注算法的本身，而不是语言层面的东西。所以本教程，其实各语言都会使用一些，并不局限于 java、go。但是，我绝对不会使用任何语法特性！我希望大家不要被语言所束缚！ 是否可以按照本教程顺序来刷题 当然可以。一般刷题我们有两种策略，一种就是刷 leetcode 前一百道题目，另一种就是根据分类刷题。刷 leetcode 前一百道题，是因为这些题目都是经典题目。而根据分类，更适合算法小白和初中阶段读者。所以我在这里选择了根据分类来汇编，这样我们还可以在做一些题目的时候，与前面同类型的题目进行比较。 这些题目刷完能达到什么效果 刷完再说！ 你需要做什么 开干！奥利给！ 看完题目还是不懂怎么办？ 下方扫码，加我微信，我拉你到刷题群。和大家一起交流学习！（备注：进群） 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-06 18:54:26 "},"c0/001.html":{"url":"c0/001.html","title":"01.两个数组的交集(350)","keywords":"","body":"两个数组的交集 01、题目分析 我们先来看一道题目： 第350题：两个数组的交集 给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2,2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？将如何优化你的算法呢？ 思路：设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组。 02、题解分析 首先拿到这道题，我们基本马上可以想到，此题可以看成是一道传统的映射题（map映射），为什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一致。这样就导致了我们需要知道每个值出现的次数，所以映射关系就成了。剩下的就是顺利成章的解题。 由于该种解法过于简单，我们不做进一步分析，直接给出题解： //GO func intersect(nums1 []int, nums2 []int) []int { m0 := map[int]int{} for _, v := range nums1 { //遍历nums1，初始化map m0[v] += 1 } k := 0 for _, v := range nums2 { //如果元素相同，将其存入nums2中，并将出现次数减1 if m0[v] > 0 { m0[v] -=1 nums2[k] = v k++ } } return nums2[0:k] } 这个方法比较简单，相信大家都能看的懂！ 03、题目进阶 题目在进阶问题中问道：如果给定的数组已经排好序呢？你将如何优化你的算法？我们分析一下，假如两个数组都是有序的，分别为：arr1 = [1,2,3,4,4,13]，arr2 = [1,2,3,9,10] 对于两个已经排序好数组的题，我们可以很容易想到使用双指针的解法~ 解题步骤如下： 设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组。下图中我们的指针分别指向第一个元素，判断元素相等之后，将相同元素放到空白的数组。 如果两个指针的元素不相等，我们将小的一个指针后移。图中我们指针移到下一个元素，判断不相等之后，将元素小的指针向后移动，继续进行判断。 反复以上步骤。 直到任意一个数组终止。 04、题目解答 根据分析，我们很容易得到下面的题解： //GO func intersect(nums1 []int, nums2 []int) []int { i, j, k := 0, 0, 0 sort.Ints(nums1) sort.Ints(nums2) for i nums2[j] { j++ } else if nums1[i] 提示：解答中我们并没有创建空白数组，因为遍历后的数组其实就没用了。我们可以将相等的元素放入用过的数组中，就为我们节省下了空间。 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-03 00:33:16 "},"c0/002.html":{"url":"c0/002.html","title":"02.最长公共前缀(14)","keywords":"","body":"最长公共前缀 01、题目分析 首先还是看下题目： 题目14: 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，则返回\"\" 示例1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明： 所有输入只包含小写字母 a-z 02、题解分析 我们要想寻找最长公共前缀，那么首先这个前缀是公共的，我们可以从任意一个元素中找到它。假定我们现在就从一个数组中寻找最长公共前缀，那么首先，我们可以将第一个元素设置为基准元素x0。假如数组为[\"flow\",\"flower\",\"flight\"]，flow就是我们的基准元素x0。 然后我们只需要依次将基准元素和后面的元素进行比较（假定后面的元素依次为x1,x2,x3....），不断更新基准元素，直到基准元素和所有元素都满足最长公共前缀的条件，就可以得到最长公共前缀。 具体比对过程如下： 如果strings.Index(x1,x) == 0，则直接跳过（因为此时x就是x1的最长公共前缀），对比下一个元素。（如flower和flow进行比较） 如果strings.Index(x1,x) != 0, 则截取掉基准元素x的最后一个元素，再次和x1进行比较，直至满足string.Index(x1,x) == 0，此时截取后的x为x和x1的最长公共前缀。（如flight和flow进行比较，依次截取出flow-flo-fl，直到fl被截取出，此时fl为flight和flow的最长公共前缀） 具体过程如下图所示： 我们需要注意的是，在处理基准元素的过程中，如果基准元素和任一一个元素无法匹配，则说明不存在最长公共元素。 最后，我们记得处理一下临界条件。如果给定数组是空，也说明没有最长公共元素。 然后我们就可以开始写我们的代码了。 03、代码分析 根据分析，我们很容易得到下面的题解： //GO func longestCommonPrefix(strs []string) string { if len(strs) 运行结果： 当然，我们也可以用分治法或者其他方法来解答这道题目。你可以自己尝试尝试哈。我们下期见！ 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "},"c0/003.html":{"url":"c0/003.html","title":"03.买卖股票的最佳时机(122)","keywords":"","body":"买卖股票的最佳时机 01、题目分析 在leetcode上，股票相关的题目有8道之多： 而且这一类型的题，面试时出现的频率非常的高。稍微改一改条件，就让我们防不胜防。那我们如何攻克这一类题型呢？我们从最简单的一道开始看起： 第122题：买卖股票的最佳时机 II 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 ​ 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 ​ 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 ​ 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 题目分析：首先我们看一下题目中给出的两个条件： 1、不能参与多笔交易。换句话讲，我们只能在手上没有股票的时候买入，也就是必须在再次购买前出售掉之前的股票。像我们平时买股票时的追涨杀跌是不可以的。 2、尽可能地多进行交易。这个非常好理解。像是黄金，一年基本上都有2-3次涨跌。我们只要把握住机会，在每一次涨跌的时候，低价卖入高价卖出，就可以使利益达到最大化。这个条件也是相当重要的，如果我们把这里变成，最多完成两笔交易，就变成另一道题。 现在题目搞清楚了，我们来思考一下。 02、题解分析 假设给定的数组为：[7, 1, 5, 3, 6, 4] 我们将其绘制成折线图，大概是下面这样： 如我们上面分析，我们要在满足1和2的条件下获取最大利益，其实就是尽可能多的低价买入高价卖出。而每一次上升波段，其实就是一次低价买入高价卖出。而我们没有限制交易次数，也就是我们需要求出所有的上升波段的和。上图里就是A+B，也就是（5-1）+（6-3） = 7，就是我们能获取到的最大利益。 其实也就是尽可能多的低价买入，高价卖出啦。 03、代码分析 根据以上分析，我们很容易得到下面的题解： //GO func maxProfit(prices []int) int { if len(prices) b { return a } return b } 04、题目扩展 图解的方式其实在各种算法题中，屡见不鲜。而我们通过图解的方式，也可以抽丝剥茧一样，一层一层剥掉算法题目的外壳，寻找到最直观的解题思路，直捣黄....咳咳，直奔核心。那我们又如何用图解的观察方式，来对本系列的其他题目寻找到一种通用解法，来规避题目中的陷阱呢？浩仔讲算法，我们下期再见喽！ 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "},"c0/004.html":{"url":"c0/004.html","title":"04.旋转数组(189)","keywords":"","body":"旋转数组 01、题目分析 题目189: 旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 这道题如果不要求原地翻转的话，其实相当简单。但是原地翻转的方法却并不容易想到，我们直接看题解。 02、题目图解 这个方法基于这个事实：若我们需要将数组中的元素向右移动 k 个位置， 那么 k%l (l为数组长度) 的尾部元素会被移动到头部，剩下的元素会被向后移动。 假设 我们现在数组为[1,2,3,4,5,6,7], l=7 且 k=3 。 如下图可以看到5,6,7 被移动到 数组头部。 通过观察我们可以得到，我们要得到最终的结果。我们只需要将所有元素反转，然后反转前 k 个元素，再反转后面l-k个元素，就能得到想要的结果。 如下图： 03、题目解答 根据分析，我们可以得到下面的题解： //GO func rotate(nums []int, k int) { reverse(nums) reverse(nums[:k%len(nums)]) reverse(nums[k%len(nums):]) } func reverse(arr []int) { for i := 0; i 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "},"c0/005.html":{"url":"c0/005.html","title":"05.原地删除(27)","keywords":"","body":"原地删除 01、题目分析 题目27：移除元素 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 这道题比较简单哦，只要把握好“原地删除”这个关键字，就可以顺利求解啦！ 具体过程如下图所示： 根据分析，我们可以得到下面的题解： //GO func removeElement(nums []int, val int) int { for i := 0; i 和这道题类似的还有LeetCode 26题，大家可以尝试自己先做一做，然后再看答案哦。 02、类似题目分析 题目26：删除排序数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次。 返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 这道题的重点是原地两个字，也就是要求必须在O(1)的空间下完成。并且题中已经告知了数组为有序数组，这样重复的元素一定是连在一起的，我们只需要一个一个移除重复的元素即可，具体方案方案怎么做，我们看看下面就会明白了。 移除的具体过程： 根据分析，我们可以得到下面的题解： //GO func removeDuplicates(nums []int) int { for i := 0; i+1 好啦，关于数组原地操作的两道题就讲到这里啦，如果大家有兴趣的话，可以参考做一下LeetCode 283题（移动O），也是一样的做法哦！ 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "},"c0/006.html":{"url":"c0/006.html","title":"06.加一(66)","keywords":"","body":"加一 看到这个标题，大家肯定会觉得，不就是“加1”嘛，这么简单的问题我可以！但是就是这么简单的“加1”可是面试的高频题哦，所以我们就一起来看看吧。按照往例，我们还是从一道LeetCode题开始吧。 01、题目分析 第66题：加一 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 题目分析： 根据题目，我们需要加一！没错，加一很重要。因为它只是加一，所以我们会考虑到两种情况： 普通情况，除9之外的数字加1。 特殊情况，9加1。（因为9加1需要进位） 所以我们只需要模拟这两种运算，就可以顺利进行求解！ 02、题目图解 假设我们的数为[1,9,9] 大概是下面这样：（这个图解...真的有点太简单了...） 当然，这里我们需要考虑一种特殊情况，就是类似99，或者999，我们需要进行拼接数组。具体如下图： 通过以上分析，我们最后只需要将其转换成代码即可！这样看来，“加1”是不是也不像想象中的那么简单？ 03、GO语言示例 根据以上分析，我们可以得到下面的题解： func plusOne(digits []int) []int { var result []int addon := 0 for i := len(digits) - 1;i >= 0; i-- { digits[i]+=addon addon = 0 if i == len(digits) - 1 { digits[i]++ } if digits[i] == 10 { addon = 1 digits[i] = digits[i] % 10 } } if addon == 1 { result = make([]int, 1) result[0] = 1 result = append(result,digits...) }else{ result = digits } return result } 提示: append(a,b...) 的含义是：将b切片中的元素追加到a中。 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "},"c0/007.html":{"url":"c0/007.html","title":"07.两数之和(1)","keywords":"","body":"两数之和 01、题目分析 第1题：两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 题目分析 首先我们拿到题目一看，马上可以想到暴力题解。我们只需要 “遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。” 由于该种解题思路过于简单，直接上代码（如果有问题请留言..）： func twoSum(nums []int, target int) []int { for i, v := range nums { for k := i + 1; k 执行结果： 运行成功，但是该种解题方式的时间复杂度过高，达到了O(n²)。为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。我们可以想到用哈希表的方式，通过以空间换取时间的方式来进行。 02、题目图解 假设 nums = [2, 7, 11, 15], target = 9 首先，我们还是先遍历数组 nums，i 为当前下标。我们需要将每一个遍历的值放入 map 中作为 key。 同时，对每个值都判断 map 中是否存在 target-nums[i] 的 key 值。在这里就是 9-7=2。我们可以看到 2 在 map 中已经存在。 所以，2 和 7 所在的 key 对应的 value，也就是 [0,1]。就是我们要找的两个数组下标。 03、Go语言示例 根据以上分析，我们可以得到下面的题解： func twoSum(nums []int, target int) []int { result := []int{} m := make(map[int]int) for i,k := range nums { if value,exist := m[target-k];exist { result = append(result,value) result = append(result,i) } m[k] = i } return result } 执行结果： 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "},"c1/101.html":{"url":"c1/101.html","title":"01.删除链表倒数第N个节点(19)","keywords":"","body":"删除链表倒数第N个节点 01、哨兵节点 在链表的题目中，十道有九道会用到哨兵节点，所以我们先讲一下什么是哨兵节点。 哨兵节点，其实就是一个附加在原链表最前面用来简化边界条件的附加节点，它的值域不存储任何东西，只是为了操作方便而引入。 比如原链表为a->b->c，则加了哨兵节点的链表即为x->a->b>c，如下图： 那我们为什么需要引入哨兵节点呢?举个例子，比如我们要删除某链表的第一个元素，常见的删除链表的操作是找到要删元素的前一个元素，假如我们记为 pre。我们通过： pre.Next = pre.Next.Next 来进行删除链表的操作。但是此时若是删除第一个元素的话，你就很难进行了，因为按道理来讲，此时第一个元素的前一个元素就是nil（空的），如果使用pre就会报错。那如果此时你设置了哨兵节点的话，此时的pre就是哨兵节点了。这样对于链表中的任何一个元素，你要删除都可以通过pre.Next=pre.Next.Next的方式来进行，这就是哨兵节点的作用。 下面我们看一道题目，看一下哨兵节点的应用 02、题目讲解 第19题：删除链表倒数第N个节点 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1->2->3->4->5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1->2->3->5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 思路分析： 首先我们思考，让我们删除倒数第N个元素，那我们只要找到倒数第N个元素就可以了，那怎么找呢？我们只需要设置两个指针变量，中间间隔N-1元素。当后面的指针遍历完所有元素指向nil时，前面的指针就指向了我们要删除的元素。如下图所示： 接下来，我们只要同时定位到要删除的元素的前1个元素，通过前面讲过的删除操作，就可以很顺利的完成这道题目啦。 03、解题过程 现在我们来完整捋一遍解题过程： 首先我们定义好哨兵节点result，指向哨兵节点的目标元素指针cur，以及目标指针cur的前一个指针pre，此时pre指向nil。 接下来我们开始遍历整个链表。 当head移动到距离目标元素cur的距离为N-1时，同时开始移动cur。 当链表遍历完之后，此时head指向nil，这时的cur就是我们要找的待删除的目标元素。 最后我们通过pre.Next = pre.Next.Next完成删除操作，就完成了整个解题过程。 下面是解题过程图，可以看得更清楚哦。 04、题目解答 根据以上分析，我们可以得到下面的题解： func removeNthFromEnd(head *ListNode, n int) *ListNode { result := &ListNode{} result.Next = head var pre *ListNode cur := result i := 1 for head != nil { if i >= n { pre = cur cur = cur.Next } head = head.Next i++ } pre.Next = pre.Next.Next return result.Next } 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "},"c1/102.html":{"url":"c1/102.html","title":"02.合并两个有序链表(21)","keywords":"","body":"合并两个有序链表 01、题目分析 第21题：合并两个有序链表 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 首先我们拿到题目乍眼一看，类似这种链表的合并问题。基本上马上可以想到需要设置一个哨兵节点，这可以在最后让我们比较容易地返回合并后的链表。（不懂哨兵节点的同学，可以先移驾到 06.删除链表倒数第N个节点(19) 进行学习） 假设我们的链表分别为: l1 = [1,2,4] l2 = [1,3,4] 同时我们设定一个 \"prehead\" 的哨兵节点,大概是下面这样： 02、题目图解 如上图所示，首先我们维护一个 prehead 的哨兵节点。我们其实只需要调整它的 next 指针。让它总是指向l1或者l2中较小的一个，直到l1或者l2任一指向null。这样到了最后，如果l1还是l2中任意一方还有余下元素没有用到，那余下的这些元素一定大于prehead已经合并完的链表（因为是有序链表）。我们只需要将这些元素全部追加到prehead合并完的链表后，最终就得到了我们需要的链表。大概流程如下： 首先我们将 prehead 指向 l1 或者 l2 中比较小的一个。如果相等，则任意一个都可以。此时的 l1 为 [2,4]，l2 为 [1,3,4] 我们继续上面的步骤。将 prehead 的链表指向 l1 和 l2 中较小的一个。现在这里就是指向1。 反复上图步骤。 现在 prehead.Next 就是我们需要的链表。 03、Go语言示例 根据以上分析，我们可以得到下面的题解： func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { prehead := &ListNode{} result := prehead for l1 != nil && l2 != nil { if l1.Val 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "},"c2/201.html":{"url":"c2/201.html","title":"01.爬楼梯(70)","keywords":"","body":"DP 第一讲 - 爬楼梯 01、概念讲解 关于动态规划的资料很多，官方的定义是指把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。概念中的各阶段之间的关系，其实指的就是状态转移方程。很多人觉得DP难（下文统称动态规划为DP），根本原因是因为DP跟一些固定形式的算法不同（比如DFS、二分法、KMP），它没有实际的步骤规定第一步、第二步来做什么，所以准确来说，DP其实是一种解决问题的思想。 这种思想的本质是：一个规模比较大的问题（可以用两三个参数表示的问题），可以通过若干规模较小的问题的结果来得到的（通常会寻求到一些特殊的计算逻辑，如求最值等），如下图所示，一个大规模的问题由若干个子问题组成。 那么我们应该如何通过子问题去得到大规模问题呢？这就用到了状态转移方程（上面有介绍状态转移方程哦，不懂的请往上翻哦），我们一般看到的状态转移方程，基本都是这样： opt ：指代特殊的计算逻辑，通常为 max or min。 i,j,k 都是在定义DP方程中用到的参数。 dp[i] = opt(dp[i-1])+1 dp[i][j] = w(i,j,k) + opt(dp[i-1][k]) dp[i][j] = opt(dp[i-1][j] + xi, dp[i][j-1] + yj, ...) 每一个状态转移方程，多少都有一些细微的差别。这个其实很容易理解，世间的关系多了去了，不可能抽象出完全可以套用的公式。所以我个人其实不建议去死记硬背各种类型的状态转移方程。但是DP的题型真的就完全无法掌握，无法归类进行分析吗？我认为不是的。在本系列中，我将由简入深为大家讲解动态规划这个主题。 02、题目分析 我们先看一道最简单的DP题目，熟悉DP的概念： 第70题：爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 03 、图解分析 通过分析我们可以明确，该题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建。满足“将大问题分解为若干个规模较小的问题”的条件。所我们令 dp[n] 表示能到达第 n 阶的方法总数，可以得到如下状态转移方程： dp[n]=dp[n-1]+dp[n-2] 上 1 阶台阶：有1种方式。 上 2 阶台阶：有1+1和2两种方式。 上 3 阶台阶：到达第3阶的方法总数就是到第1阶和第2阶的方法数之和。 上 n 阶台阶，到达第n阶的方法总数就是到第 (n-1) 阶和第 (n-2) 阶的方法数之和。 04、GO语言示例 根据以上分析，可以得到代码如下： func climbStairs(n int) int { if n == 1 { return 1 } dp := make([]int, n+1) dp[1] = 1 dp[2] = 2 for i := 3; i 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "},"c2/202.html":{"url":"c2/202.html","title":"02.最大子序和(53)","keywords":"","body":"DP 第二讲 - 最大子序和 在上一篇文章011.动态规划系列 —第一讲(70)中，我们讲解了DP的概念并且通过示例了解了什么是动态规划。本篇中，我们将继续通过1道简单题型，进一步学习动态规划的思想。 01、题目分析 第53题：最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 拿到题目请不要直接看下方题解，先自行思考2-3分钟.... 02、题目图解 首先我们分析题目，一个连续子数组一定要以一个数作为结尾，那么我们可以将状态定义成如下： dp[i]：表示以 nums[i] 结尾的连续子数组的最大和。 那么为什么这么定义呢？因为这样定义其实是最容易想到的！在上一节中我们提到，状态转移方程其实是通过1-3个参数的方程来描述小规模问题和大规模问题间的关系。 当然，如果你没有想到，其实也非常正常！因为该问题最早于 1977 年提出，但是直到 1984 年才被发现了线性时间的最优解法。 根据状态的定义，我们继续进行分析：如果要得到 dp[i]，那么 nums[i] 一定会被选取。并且 dp[i] 所表示的连续子序列与 dp[i-1] 所表示的连续子序列很可能就差一个 nums[i] 。即： dp[i] = dp[i-1]+nums[i] , if (dp[i-1] >= 0) 但是这里我们遇到一个问题，很有可能 dp[i-1] 本身是一个负数。那这种情况的话，如果 dp[i] 通过 dp[i-1]+nums[i] 来推导，那么结果其实反而变小了，因为我们 dp[i] 要求的是最大和。所以在这种情况下，如果 dp[i-1] 。即 dp[i] = nums[i] , if (dp[i-1] 综上分析，我们可以得到： dp[i]=max(nums[i], dp[i−1]+nums[i]) 得到了状态转移方程，但是我们还需要通过一个已有的状态的进行推导，我们可以想到 dp[0] 一定是以 nums[0] 进行结尾，所以 dp[i] = dp[i-1]+nums[i] , if (dp[i-1] >= 0) dp[0] = nums[0] 在很多题目中，因为 dp[i] 本身就定义成了题目中的问题，所以 dp[i] 最终就是要的答案。但是这里状态中的定义，并不是题目中要的问题，不能直接返回最后的一个状态 (这一步经常有初学者会摔跟头)。所以最终的答案，其实我们是寻找： max(dp[0], dp[1], ..., d[i-1], dp[i]) 分析完毕，我们绘制成图（图中假定 nums 为 [-2,1,-3,4,-1,2,1,-5,4]）： 03、Go语言示例 根据以上分析，可以得到代码如下： //Go func maxSubArray(nums []int) int { if len(nums) b { return a } return b } 我们可以进一步精简代码为： //Go func maxSubArray(nums []int) int { if len(nums) b { return a } return b } 复杂度分析：时间复杂度：O(N)。空间复杂度：O(N) 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "},"c2/203.html":{"url":"c2/203.html","title":"03.最长上升子序列(300)","keywords":"","body":"DP 第三讲 - 最长上升子序列 在上一篇中，我们了解了什么是DP（动态规划），并且通过DP中的经典问题 \"最大子序和\"，学习了状态转移方程应该如何定义。在本节中，我们将沿用之前的分析方法，通过一道例题，进一步巩固之前的内容！ 01、题目分析 第300题：最长上升子序列 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 这道题有一定难度哦！如果没有思路请回顾上一篇的学习内容！ 不建议直接看题解！ 02、题目图解 首先我们分析题目，要找的是最长上升子序列（Longest Increasing Subsequence，LIS）。因为题目中没有要求连续，所以LIS可能是连续的，也可能是非连续的。同时，LIS符合可以从其子问题的最优解来进行构建的条件。所以我们可以尝试用动态规划来进行求解。首先我们定义状态： dp[i] ：表示以nums[i]结尾的最长上升子序列的长度 我们假定nums为[1，9，5，9，3]，如下图： 我们分两种情况进行讨论： 如果nums[i]比前面的所有元素都小，那么dp[i]等于1（即它本身）（该结论正确） 如果nums[i]前面存在比他小的元素nums[j]，那么dp[i]就等于dp[j]+1（该结论错误，比如nums[3]>nums[0]，即9>1,但是dp[3]并不等于dp[0]+1） 我们先初步得出上面的结论，但是我们发现了一些问题。因为dp[i]前面比他小的元素，不一定只有一个！ 可能除了 nums[j]，还包括 nums[k]，nums[p] 等等等等。所以 dp[i] 除了可能等于 dp[j]+1，还有可能等于 dp[k]+1，dp[p]+1 等等等等。所以我们求 dp[i]，需要找到 dp[j]+1，dp[k]+1，dp[p]+1 等等等等 中的最大值。（我在3个等等等等上都进行了加粗，主要是因为初学者非常容易在这里摔跟斗！这里强调的目的是希望能记住这道题型！） 即： dp[i] = max(dp[j]+1，dp[k]+1，dp[p]+1，.....) 只要满足： nums[i] > nums[j] nums[i] > nums[k] nums[i] > nums[p] .... 最后，我们只需要找到dp数组中的最大值，就是我们要找的答案。 分析完毕，我们绘制成图： 03、Go语言示例 根据以上分析，可以得到代码如下： func lengthOfLIS(nums []int) int { if len(nums) b { return a } return b } 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "},"c2/204.html":{"url":"c2/204.html","title":"04.三角形最小路径和(120)","keywords":"","body":"DP 第二讲 - 三角形最小路径和 在上一篇中，我们通过题目“最长上升子序列” 以及 \"最大子序和\"，学习了DP（动态规划）在线性关系中的分析方法。这种分析方法，也在运筹学中被称为“线性动态规划”，具体指的是 “目标函数为特定变量的线性函数，约束是这些变量的线性不等式或等式，目的是求目标函数的最大值或最小值”。这点大家作为了解即可，不需要死记，更不要生搬硬套！ 在本节中，我们将继续分析一道略微区别于之前的题型，希望可以由此题与之前的题目进行对比论证，进而顺利求解！ 01、题目分析 第120题：三角形最小路径和 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 则自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 这道题有一定难度哦！如果没有思路请回顾上一篇的学习内容！ 不建议直接看题解！ 02、题目图解 首先我们分析题目，要找的是三角形最小路径和，这是个啥意思呢？假设我们有一个三角形：[[2], [3,4], [6,5,7]， [4,1,8,3]] 那从上到下的最小路径和就是2-3-5-1，等于11。 由于我们是使用数组来定义一个三角形，所以便于我们分析，我们将三角形稍微进行改动： 这样相当于我们将整个三角形进行了拉伸。这时候，我们根据题目中给出的条件：每一步只能移动到下一行中相邻 的结点上。其实也就等同于，每一步我们只能往下移动一格或者右下移动一格。将其转化成代码，假如2所在的元 素位置为[0,0]，那我们往下移动就只能移动到[1,0]或者[1,1]的位置上。假如5所在的位置为[2,1]，同样也只能移动 到[3,1]和[3,2]的位置上。如下图所示： 题目明确了之后，现在我们开始进行分析。题目很明显是一个找最优解的问题，并且可以从子问题的最优解进 行构建。所以我们通过动态规划进行求解。首先，我们定义状态： dp[i][j] : 表示包含第i行j列元素的最小路径和 我们很容易想到可以自顶向下进行分析。并且，无论最后的路径是哪一条，它一定要经过最顶上的元素，即 [0,0]。所以我们需要对 dp[0][0] 进行初始化。 dp[0][0] = [0][0]位置所在的元素值 继续分析，如果我们要求dp[i][j]，那么其一定会从自己头顶上的两个元素移动而来。 如5这个位置的最小路径和，要么是从2-3-5而来，要么是从2-4-5而来。然后取两条路径和中较小的一个即可。进 而我们得到状态转移方程： dp[i][j] = min(dp[i-1][j-1],dp[i-1][j]) + triangle[i][j] 但是，我们这里会遇到一个问题！除了最顶上的元素之外， 最左边的元素只能从自己头顶而来。（2-3-6-4） 最右边的元素只能从自己左上角而来。（2-4-7-3） 然后，我们观察发现，位于第2行的元素，都是特殊元素（因为都只能从[0,0]的元素走过来） 我们可以直接将其特殊处理，得到： dp[1][0] = triangle[1][0] + triangle[0][0] dp[1][1] = triangle[1][1] + triangle[0][0] 最后，我们只要找到最后一行元素中，路径和最小的一个，就是我们的答案。即： l：dp数组长度 result = min(dp[l-1,0]，dp[l-1,1]，dp[l-1,2]....) 综上我们就分析完了，我们总共进行了4步： 定义状态 总结状态转移方程 分析状态转移方程不能满足的特殊情况。 得到最终解 03、Go语言示例 根据以上分析，可以得到代码如下： func minimumTotal(triangle [][]int) int { if len(triangle) b { return b } return a } 运行结果： 运行上面的代码，我们发现使用的内存过大。我们有没有什么办法可以压缩内存呢？通过观察我们发现，在我们 自顶向下的过程中，其实我们只需要使用到上一层中已经累积计算完毕的数据，并且不会再次访问之前的元素数 据。绘制成图如下： 优化后的代码如下： func minimumTotal(triangle [][]int) int { l := len(triangle) if l b { return b } return a } 运行结果： 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-06 09:33:08 "},"c2/205.html":{"url":"c2/205.html","title":"05.最小路径和(64)","keywords":"","body":"DP 第五讲 - 最小路径和 在上一篇中，我们通过分析，顺利完成了“三角形最小路径和”的动态规划题解。在本节中，我们继续看一道相似题型，以求能完全掌握这种“路径和”的问题。话不多说，先看题目： 01、题目分析 第64题：最小路径和 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 这道题有一定难度哦！如果没有思路请回顾上一篇的学习内容！ 不建议直接看题解！ 02、题目图解 首先我们分析题目，要找的是 最小路径和，这是个啥意思呢？假设我们有一个 m * n 的矩形 ：[[1,3,1],[1,5,1],[4,2,1]] 那从左上角到右下角的最小路径和，我们可以很容易看出就是 1-3-1-1-1 ，这一条路径，结果等于 7 。 题目明确了，我们继续进行分析。该题与上一道求三角形最小路径和一样，题目明显符合可以从子问题的最优解进行构建，所以我们考虑使用动态规划进行求解。首先，我们定义状态： dp[i][j] : 表示包含第i行j列元素的最小路径和 同样，因为任何一条到达右下角的路径，都会经过 [0,0] 这个元素。所以我们需要对 dp[0][0] 进行初始化。 dp[0][0] = [0][0]位置所在的元素值 继续分析，根据题目给的条件，如果我们要求 dp[i][j] ，那么它一定是从自己的上方或者左边移动而来。如下图所示： 5，只能从3或者1移动而来 2，只能从5或者4移动而来 4，从1移动而来 3，从1移动而来 （红色位置必须从蓝色位置移动而来） 进而我们得到状态转移方程： dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j] 同样我们需要考虑两种特殊情况： 最上面一行，只能由左边移动而来（1-3-1） 最左边一列，只能由上面移动而来（1-1-4） 最后，因为我们的目标是从左上角走到右下角，整个网格的最小路径和其实就是包含右下角元素的最小路径和。即： 设：dp的长度为l 最终结果就是：dp[l-1][len(dp[l-1])-1] 综上我们就分析完了，我们总共进行了 4 步： 定义状态 总结状态转移方程 分析状态转移方程不能满足的特殊情况。 得到最终解 03、GO语言示例 根据以上分析，可以得到代码如下： func minPathSum(grid [][]int) int { l := len(grid) if l b { return b } return a } 运行结果： 同样，运行上面的代码，我们发现使用的内存过大。有没有什么办法可以压缩内存呢？通过观察我们发现，在我们自左上角到右下角计算各个节点的最小路径和的过程中，我们只需要使用到之前已经累积计算完毕的数据，并且不会再次访问之前的元素数据。绘制成图如下：(大家看这个过程像不像扫雷，其实如果大家研究扫雷外挂的话，就会发现在扫雷的核心算法中，就有一处颇为类似这种分析方法，这里就不深究了) 优化后的代码如下： func minPathSum(grid [][]int) int { l := len(grid) if l b { return b } return a } 运行结果： 课后思考：路径和类问题和之前的子序列类问题有何区别？ 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-06 09:33:08 "},"c2/206.html":{"url":"c2/206.html","title":"06.打家劫舍(198)","keywords":"","body":"DP 第六讲 - 打家劫舍 在前两篇中，我们分别学习了 “三角形最小路径和” 以及“矩形最小路径和” 的问题，相信已经掌握了这类题型的解题方式。我们只要明确状态的定义，基本上都可以顺利求解。 在本节中，我们将回归一道简单点的题目，目的是剖析一下状态定义的过程，并且举例说明如果状态定义错误，会对我们带来多大困扰！希望大家不要轻视！ 01、题目分析 第198题：打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 本题主要剖析状态定义的过程！强烈建议先进行前面5节内容的学习！ 以达到最好的学习效果！ 02、题目图解 假设有i间房子，我们可能会定义出两种状态： dp[i] : 偷盗 含 第 i个房子时，所获取的最大利益 dp[i] : 偷盗 至 第 i个房子时，所获取的最大利益 如果我们定义为状态一，因为我们没办法知道获取最高金额时，小偷到底偷盗了哪些房屋。所以我们需要找到所有状态中的最大值，才能找到我们的最终答案。即： max(dp[0],dp[1],.....,dp[len(dp)-1]) 如果我们定义为状态二，因为小偷一定会从前偷到最后（强调：偷盗至第i个房间，不代表小偷要从第i个房间中获取财物）。所以我们的最终答案很容易确定。即： dp[i] 现在我们分析这两种状态定义下的状态转移方程： 如果是状态一，偷盗含第 i 个房间时能获取的最高金额，我们相当于要找到偷盗每一间房子时可以获取到的最大金额。比如下图，我们要找到 dp[4] ，也就是偷盗 9 这间房子时，能获取到的最大金额。 那我们就需要找到与9不相邻的前后两段中能获取到的最大金额。 我们发现题目进入恶性循环，因为我们若要找到与9不相邻的两端中能偷盗的最大金额，根据 dp[i] 的定义，我们就又需要分析在这两段中盗取每一间房子时所能获取的最大利益！想想都很可怕！所以我们放弃掉这种状态的定义。 如果是状态二，偷盗至第 i 个房子时，所能获取的最大利益。那我们可以想到，由于不可以在相邻的房屋闯入，所以 至i房屋可盗窃的最大值，要么就是至 i-1 房屋可盗窃的最大值，要么就是至 i-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值，即： dp[i] = max(dp[i-2]+nums[i], dp[i-1]) 如果不能理解可以看下图： （相当于小贼背了个背包，里边装了之前偷来的财物，每到达下一个房间门口，来选择是偷还是不偷。） 03、GO语言示例 分析完毕，我们根据第二种状态定义进行求解： func rob(nums []int) int { if len(nums) b { return a } return b } 运行结果： 同样，运行上面的代码，我们发现使用的内存过大。有没有什么办法可以压缩内存呢？我们很容易想到，在小贼偷盗的过程中，不可能转回头去到自己已经偷过的房间！（太蠢）小偷只需要每次将财物搬到下一个房间就行！ 根据上面思路，优化后的代码如下： func rob(nums []int) int { if len(nums) b { return a } return b } 运行结果： 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-06 09:34:02 "},"c3/301.html":{"url":"c3/301.html","title":"01.反转字符串(344)","keywords":"","body":"反转字符串 01、题目分析 第344题：反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 示例 1： 输入：[\"h\",\"e\",\"l\",\"l\",\"o\"] 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] 示例 2： 输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 02、题目图解 这是一道相当简单的经典题目，直接上题解：使用双指针进行反转字符串。 假设输入字符串为[\"h\",\"e\",\"l\",\"l\",\"0\"] 定义left和right分别指向首元素和尾元素 当left 交换完毕，left++，right-- 直至left == right 具体过程如下图所示： 03、Go语言示例 根据以上分析，我们可以得到下面的题解： //Go func reverseString(s []byte) { left := 0 right := len(s) - 1 for left 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推File Modify: 2020-06-04 00:27:58 "}}