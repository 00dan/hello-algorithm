{"./":{"url":"./","title":"Introduction","keywords":"","body":"小浩的算法书 为什么想要做这样的一本电子书 网上的算法教程杂而乱，难度忽高忽低，质量层次不齐，浪费了大家大量的宝贵时间！很多题解，在我掌握题目后去看都费劲，更何况对于一些初学者。既然如此，我不入地狱谁入地狱！ 本书阅读门槛 本书没有任何门槛，哪怕对算法一窍不通的同学。因为我会在讲解给类型题目的第一道题时，去串一串该类型的基础知识。 期望本书能达到什么样的目的？ 掌握 300 道算法题目 上面的目的还不够你骚吗？ 本书有什么特色 每一道题都配有完整的图解！全网就此一家！ 为什么不专门给出最优解？ 最优解往往都是在原始题解上多次优化而成，不一定适合所有人。有的最优解代码看起来是相当优雅，但是如果看都看不懂，那和我们有毛线的关系。我见过很多算法初学者，题目半天没思路，上来非要看最优解。看半天看不懂，然后又去找别的题解。别的题解看了会儿大体上感觉看懂了，突然发现里边有一行代码怎么样的理解不了，直到最后放弃！图什么呢？ 本书的意义 本书的意义，是期望能达到对每一个题目都提供一个可以看得懂的解法！然后在此基础上，再去保证题解的质量！懂是第一位的，如果看都看不懂，何谈掌握，何谈最优！ 题解是否严谨？ 绝对严谨，所有的题解都在leetcode上进行过测试运行。 为什么不使用同一种语言？ 我期望大家更多的是去关注算法的本身，而不是语言层面的东西。所以本书各种语言都会使用一些，包括 java、go、js、py、c、c++ 等。但是，我基本不会使用任何语言的特殊语法性质，如果有我会专门说明。我希望大家不要被语言所束缚！ 为什么不写博客 我想更专注于内容，而不是那些乱七八糟的东西。 是否可以跟着我的题目讲解顺序刷题 绝对可以！没什么好解释的，做一件事情的意义，有时候就在于做的本身。我想你跟着我完成十道题目后，就知道为什么可以了。 你需要做什么 开干！ "},"c1/001.html":{"url":"c1/001.html","title":"01.两个数组的交集(350)","keywords":"","body":"两个数组的交集 01、题目分析 我们先来看一道题目： 第350题：两个数组的交集 给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2,2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？将如何优化你的算法呢？ 思路：设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组。 02、题解分析 首先拿到这道题，我们基本马上可以想到，此题可以看成是一道传统的映射题（map映射），为什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一致。这样就导致了我们需要知道每个值出现的次数，所以映射关系就成了。剩下的就是顺利成章的解题。 由于该种解法过于简单，我们不做进一步分析，直接给出题解： //GO func intersect(nums1 []int, nums2 []int) []int { m0 := map[int]int{} for _, v := range nums1 { //遍历nums1，初始化map m0[v] += 1 } k := 0 for _, v := range nums2 { //如果元素相同，将其存入nums2中，并将出现次数减1 if m0[v] > 0 { m0[v] -=1 nums2[k] = v k++ } } return nums2[0:k] } 这个方法比较简单，相信大家都能看的懂！ 03、题目进阶 题目在进阶问题中问道：如果给定的数组已经排好序呢？你将如何优化你的算法？我们分析一下，假如两个数组都是有序的，分别为：arr1 = [1,2,3,4,4,13]，arr2 = [1,2,3,9,10] 对于两个已经排序好数组的题，我们可以很容易想到使用双指针的解法~ 解题步骤如下： 设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组。下图中我们的指针分别指向第一个元素，判断元素相等之后，将相同元素放到空白的数组。 如果两个指针的元素不相等，我们将小的一个指针后移。图中我们指针移到下一个元素，判断不相等之后，将元素小的指针向后移动，继续进行判断。 反复以上步骤。 直到任意一个数组终止。 04、题目解答 根据分析，我们很容易得到下面的题解： //GO func intersect(nums1 []int, nums2 []int) []int { i, j, k := 0, 0, 0 sort.Ints(nums1) sort.Ints(nums2) for i nums2[j] { j++ } else if nums1[i] 提示：解答中我们并没有创建空白数组，因为遍历后的数组其实就没用了。我们可以将相等的元素放入用过的数组中，就为我们节省下了空间。 本文语言虽随机选取，但不会使用复杂的语法特性。 本文出现全部代码均在 leetcode 上完整运行。 "},"c1/002.html":{"url":"c1/002.html","title":"02.最长公共前缀(14)","keywords":"","body":"最长公共前缀 01、题目分析 首先还是看下题目： 题目14: 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，则返回\"\" 示例1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明： 所有输入只包含小写字母 a-z 02、题解分析 我们要想寻找最长公共前缀，那么首先这个前缀是公共的，我们可以从任意一个元素中找到它。假定我们现在就从一个数组中寻找最长公共前缀，那么首先，我们可以将第一个元素设置为基准元素x0。假如数组为[\"flow\",\"flower\",\"flight\"]，flow就是我们的基准元素x0。 然后我们只需要依次将基准元素和后面的元素进行比较（假定后面的元素依次为x1,x2,x3....），不断更新基准元素，直到基准元素和所有元素都满足最长公共前缀的条件，就可以得到最长公共前缀。 具体比对过程如下： 如果strings.Index(x1,x) == 0，则直接跳过（因为此时x就是x1的最长公共前缀），对比下一个元素。（如flower和flow进行比较） 如果strings.Index(x1,x) != 0, 则截取掉基准元素x的最后一个元素，再次和x1进行比较，直至满足string.Index(x1,x) == 0，此时截取后的x为x和x1的最长公共前缀。（如flight和flow进行比较，依次截取出flow-flo-fl，直到fl被截取出，此时fl为flight和flow的最长公共前缀） 具体过程如下图所示： 我们需要注意的是，在处理基准元素的过程中，如果基准元素和任一一个元素无法匹配，则说明不存在最长公共元素。 最后，我们记得处理一下临界条件。如果给定数组是空，也说明没有最长公共元素。 然后我们就可以开始写我们的代码了。 03、代码分析 根据分析，我们很容易得到下面的题解： //GO func longestCommonPrefix(strs []string) string { if len(strs) 运行结果： 当然，我们也可以用分治法或者其他方法来解答这道题目。你可以自己尝试尝试哈。我们下期见！ 本文语言虽随机选取，但不会使用复杂的语法特性。 本文出现全部代码均在 leetcode 上完整运行。 "},"c1/003.html":{"url":"c1/003.html","title":"03.买卖股票的最佳时机(122)","keywords":"","body":"买卖股票的最佳时机 01、题目分析 在leetcode上，股票相关的题目有8道之多： 而且这一类型的题，面试时出现的频率非常的高。稍微改一改条件，就让我们防不胜防。那我们如何攻克这一类题型呢？我们从最简单的一道开始看起： 第122题：买卖股票的最佳时机 II 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 ​ 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 ​ 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 ​ 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 题目分析：首先我们看一下题目中给出的两个条件： 1、不能参与多笔交易。换句话讲，我们只能在手上没有股票的时候买入，也就是必须在再次购买前出售掉之前的股票。像我们平时买股票时的追涨杀跌是不可以的。 2、尽可能地多进行交易。这个非常好理解。像是黄金，一年基本上都有2-3次涨跌。我们只要把握住机会，在每一次涨跌的时候，低价卖入高价卖出，就可以使利益达到最大化。这个条件也是相当重要的，如果我们把这里变成，最多完成两笔交易，就变成另一道题。 现在题目搞清楚了，我们来思考一下。 02、题解分析 假设给定的数组为：[7, 1, 5, 3, 6, 4] 我们将其绘制成折线图，大概是下面这样： 如我们上面分析，我们要在满足1和2的条件下获取最大利益，其实就是尽可能多的低价买入高价卖出。而每一次上升波段，其实就是一次低价买入高价卖出。而我们没有限制交易次数，也就是我们需要求出所有的上升波段的和。上图里就是A+B，也就是（5-1）+（6-3） = 7，就是我们能获取到的最大利益。 其实也就是尽可能多的低价买入，高价卖出啦。 03、代码分析 根据以上分析，我们很容易得到下面的题解： //GO func maxProfit(prices []int) int { if len(prices) b { return a } return b } 04、题目扩展 图解的方式其实在各种算法题中，屡见不鲜。而我们通过图解的方式，也可以抽丝剥茧一样，一层一层剥掉算法题目的外壳，寻找到最直观的解题思路，直捣黄....咳咳，直奔核心。那我们又如何用图解的观察方式，来对本系列的其他题目寻找到一种通用解法，来规避题目中的陷阱呢？浩仔讲算法，我们下期再见喽！ 本文语言虽随机选取，但不会使用复杂的语法特性。 本文出现全部代码均在 leetcode 上完整运行。 "},"c1/004.html":{"url":"c1/004.html","title":"04.旋转数组(189)","keywords":"","body":"旋转数组 01、题目分析 题目189: 旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 这道题如果不要求原地翻转的话，其实相当简单。但是原地翻转的方法却并不容易想到，我们直接看题解。 02、题目图解 这个方法基于这个事实：若我们需要将数组中的元素向右移动 k 个位置， 那么 k%l (l为数组长度) 的尾部元素会被移动到头部，剩下的元素会被向后移动。 假设 我们现在数组为[1,2,3,4,5,6,7], l=7 且 k=3 。 如下图可以看到5,6,7 被移动到 数组头部。 通过观察我们可以得到，我们要得到最终的结果。我们只需要将所有元素反转，然后反转前 k 个元素，再反转后面l-k个元素，就能得到想要的结果。 如下图： 03、题目解答 根据分析，我们可以得到下面的题解： //GO func rotate(nums []int, k int) { reverse(nums) reverse(nums[:k%len(nums)]) reverse(nums[k%len(nums):]) } func reverse(arr []int) { for i := 0; i 本文语言虽随机选取，但不会使用复杂的语法特性。 本文出现全部代码均在 leetcode 上完整运行。 "},"c1/005.html":{"url":"c1/005.html","title":"05.原地删除(27)","keywords":"","body":"原地删除 01、题目分析 题目27：移除元素 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 这道题比较简单哦，只要把握好“原地删除”这个关键字，就可以顺利求解啦！ 具体过程如下图所示： 根据分析，我们可以得到下面的题解： //GO func removeElement(nums []int, val int) int { for i := 0; i 和这道题类似的还有LeetCode 26题，大家可以尝试自己先做一做，然后再看答案哦。 02、类似题目分析 题目26：删除排序数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次。 返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 这道题的重点是原地两个字，也就是要求必须在O(1)的空间下完成。并且题中已经告知了数组为有序数组，这样重复的元素一定是连在一起的，我们只需要一个一个移除重复的元素即可，具体方案方案怎么做，我们看看下面就会明白了。 移除的具体过程： 根据分析，我们可以得到下面的题解： //GO func removeDuplicates(nums []int) int { for i := 0; i+1 好啦，关于数组原地操作的两道题就讲到这里啦，如果大家有兴趣的话，可以参考做一下LeetCode 283题（移动O），也是一样的做法哦！ "}}